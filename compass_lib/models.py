from __future__ import annotations

import datetime
import json
import math
from pathlib import Path
from typing import TYPE_CHECKING
from typing import Annotated
from typing import Any

import pyIGRF14 as pyIGRF
from pydantic import BaseModel
from pydantic import ConfigDict
from pydantic import Field
from pydantic import PastDate
from pydantic import field_validator
from pydantic import model_validator

from compass_lib.constants import COMPASS_SECTION_SEPARATOR
from compass_lib.encoding import EnhancedJSONEncoder
from compass_lib.enums import ShotFlag
from compass_lib.utils import calc_inclination
from compass_lib.utils import decimal_year

if TYPE_CHECKING:
    from typing import Any


# from compass_lib.errors import DuplicateValueError
class DeclinationObj(BaseModel):
    survey_date: PastDate
    latitude: float = Field(..., ge=-90.0, le=90.0)
    longitude: float = Field(..., ge=-180.0, le=180.0)

    @property
    def declination(self) -> float:
        declination: float = pyIGRF.igrf_value(  # type: ignore[attr-defined,no-untyped-call]
            self.latitude,
            self.longitude,
            alt=0.0,
            year=decimal_year(
                datetime.datetime.combine(
                    self.survey_date,
                    datetime.datetime.min.time(),
                )
            ),
        )[0]
        return round(declination, 2)


class SurveyShot(BaseModel):
    from_: Annotated[
        str, Field(serialization_alias="from", min_length=1, max_length=32)
    ]
    to: Annotated[str, Field(min_length=1, max_length=32)]

    azimuth: Annotated[float, Field(ge=0, lt=360)]

    inclination: Annotated[float, Field(ge=-90, le=90)]
    length: Annotated[float, Field(ge=0)]

    # Optional Values
    flags: Annotated[str, Field(max_length=5)] | None = None
    comment: Annotated[str, Field(max_length=256)] | None = None

    azimuth2: Annotated[float, Field(ge=0, lt=360)] | None = None
    inclination2: Annotated[float, Field(ge=-90, le=90)] | None = None

    # LRUD
    left: Annotated[float, Field(ge=0)] | None = None
    right: Annotated[float, Field(ge=0)] | None = None
    up: Annotated[float, Field(ge=0)] | None = None
    down: Annotated[float, Field(ge=0)] | None = None

    model_config = ConfigDict(extra="forbid")

    @field_validator("azimuth", "inclination", mode="before")
    @classmethod
    def parse_numeric_str(cls, v: Any) -> float | None:
        if v in ("", None):
            return None

        try:
            return float(v)
        except (TypeError, ValueError) as e:
            raise ValueError(f"Expected numeric or empty value, got {v!r}") from e

    @field_validator(
        "left",
        "right",
        "up",
        "down",
        "azimuth2",
        "inclination2",
        mode="before",
    )
    @classmethod
    def validate_optional(cls, value: Any | None) -> float | None:
        if (value := cls.parse_numeric_str(value)) is None:
            return None

        return value if value > 0 else None

    @field_validator("flags", mode="before")
    @classmethod
    def normalize_flags(cls, v: Any) -> str | None:
        if v is None:
            return v

        if not isinstance(v, str):
            raise TypeError("flags must be a string")

        # Remove Start & Stop Tokens
        v = v.lstrip(ShotFlag.__start_token__)
        v = v.rstrip(ShotFlag.__end_token__)

        # Verify flag validity
        allowed_flags = {flag.value for flag in ShotFlag}
        chars = list(v.strip())

        if not all(c in allowed_flags for c in chars):
            invalid = [c for c in chars if c not in allowed_flags]
            raise ValueError(f"Invalid flag characters: {invalid}")

        # Sort alphabetically & remove duplicates for consistency
        return "".join(sorted(set(chars)))

    # ======================== VALIDATOR UTILS ======================== #

    # @classmethod
    # def validate_unique(cls, field: str, values: list) -> list:
    #     vals2check = [getattr(val, field) for val in values]
    #     dupl_vals = list(duplicates(vals2check))
    #     if dupl_vals:
    #         raise DuplicateValueError(
    #             f"[{cls.__name__}] Duplicate value found for `{field}`: "
    #             f"{dupl_vals}"
    #         )
    #     return values

    # @field_validator("to", mode="before")
    # @classmethod
    # def validate_unique_to(cls, value: str | None) -> str:
    #     """Note: Validators are only ran with custom fed values.
    #     Not autogenerated ones. Hence we need to register the name."""

    #     if value is None or value == "":
    #         return cls.to.default_factory()

    #     # 1. Verify the name is only composed of valid chars.
    #     for char in value:
    #         if char.upper() not in [
    #             *UniqueNameGenerator.VOCAB,
    #             *list("_-~:!?.'()[]{}@*&#%|$")
    #         ]:
    #             raise ValueError(f"The character `{char}` is not allowed as `name`.")

    #     if len(value) > COMPASS_MAX_NAME_LENGTH:
    #         raise ValueError(f"Name {value} is too long, maximum allowed: "
    #                          f"{COMPASS_MAX_NAME_LENGTH}")

    #     UniqueNameGenerator.register(value=value)
    #     return value


class SurveySection(BaseModel):
    cave_name: str
    name: Annotated[str, Field(min_length=1, max_length=256)]
    comment: Annotated[str, Field(max_length=512)] = ""
    correction: Annotated[list[float], Field(min_length=3, max_length=3)] = [
        0.0,
        0.0,
        0.0,
    ]
    correction2: Annotated[list[float], Field(min_length=2, max_length=2)] = [0.0, 0.0]
    survey_date: PastDate
    discovery_date: PastDate | None = None
    declination: Annotated[float, Field(..., ge=-90.0, le=90.0)]

    format: str = "DDDDUDLRLADN"
    unit: Annotated[str, Field(pattern=r"^(feet|meters)$")] = "feet"

    survey_team: Annotated[list[str], Field(min_length=0)]

    shots: Annotated[list[SurveyShot], Field(min_length=1)]

    model_config = ConfigDict(extra="forbid")

    @field_validator("survey_team", mode="before")
    @classmethod
    def strip_team_names(cls, v: list[str] | str) -> list[str]:
        if isinstance(v, str):
            v = v.split(",")

        return [name.strip() for name in v if name.strip()]


class Survey(BaseModel):
    sections: Annotated[list[SurveySection], Field(min_length=1)]

    model_config = ConfigDict(extra="forbid")

    def to_json(self, filepath: str | Path | None = None) -> str:
        filepath = Path(filepath) if filepath else None
        data = self.model_dump(by_alias=True)

        json_str = json.dumps(data, indent=4, sort_keys=True, cls=EnhancedJSONEncoder)

        if filepath is not None:
            with filepath.open(mode="w") as file:
                file.write(json_str)

        return json_str
